#uselib "user32.dll"
	#cfunc GetDC "GetDC" int
	#func  ReleaseDC "ReleaseDC" int
	#func  GetClientRect "GetClientRect" int, int
	#func  SetWindowLong "SetWindowLongA" int, int, int
	#func  GetCursorPos "GetCursorPos" int
	#cfunc WindowFromPoint "WindowFromPoint" int, int
	#func  GetWindowText "GetWindowTextA" int, int, int
	#func  DrawFocusRect "DrawFocusRect" int, int
	#func  InvertRect "InvertRect" int, int

#uselib "gdi32.dll"
	#func  StretchBlt "StretchBlt" int, int,int, int, int, int, int, int, int, int, int

#packopt name "switcher"
#packopt hide 1

#define ASPECT (4.0 / 3.0)

#enum WIN_SW = 1
#enum WIN_BUF1
#enum WIN_BUF2
#enum WIN_BUF3
#enum WIN_OUT1
#enum WIN_OUT2

	dim mousexy, 2
	dim rect, 4
	dim p_hwnd
	dim p_hdc
	sdim cur_title, 256
	dimtype cur_aspect, vartype("double")

	dim target_hwnd, 3
	dim target_hdc, 3
	dim target_w, 3
	dim target_h, 3

	dim win_id, 2
	dim out_hdc, 2
	dim status, 2

	win_id(0) = WIN_OUT1
	win_id(1) = WIN_OUT2

	status(0) = 0
	status(1) = 1

	// 操作ウィンドウ
	screen WIN_SW
	gsel WIN_SW, 2

	repeat 3
		i = cnt
		p_hwnd = 0

		repeat
			redraw 0
			
			color 255, 255, 255
			boxf
			color 0, 0, 0
			pos 0, 0
			mes "入力" + (i + 1)
			mes "(Ctrlで確定)"
			mes ""

			// マウスカーソル下のウィンドウを取得
			GetCursorPos varptr(mousexy)
			target_hwnd(i) = WindowFromPoint(mousexy(0), mousexy(1))
			target_hdc(i) = GetDC(target_hwnd(i))
			GetWindowText target_hwnd(i), varptr(cur_title), 256

			// 枠線を描画
			if (target_hwnd(i) != p_hwnd) {
				// 前の枠線を消す
				if (p_hwnd) {
					GetClientRect p_hwnd, varptr(rect)
					DrawFocusRect p_hdc, varptr(rect)
				}

				// 枠線を描画
				if (target_hwnd(i)) {
					GetClientRect target_hwnd(i), varptr(rect)
					DrawFocusRect target_hdc(i), varptr(rect)
				}

				// 前回の情報を保持
				p_hwnd = target_hwnd(i)
				p_hdc = target_hdc(i)
			}

			mes "" + mousexy(0) + ", " + mousexy(1)
			mes cur_title

			redraw 1

			// Ctrlが押されたら確定
			stick key, 0, 0
			if (key & 64): break
			await 10

			ReleaseDC target_hdc(i)
		loop

		// ウィンドウを登録
		target_hwnd(cnt) = cur_hwnd
		target_hdc(cnt) = GetDC(target_hwnd(cnt))
		GetClientRect target_hwnd(cnt), varptr(rect)
		target_w(cnt) = rect(2)
		target_h(cnt) = rect(3)
	loop

	// バッファウィンドウ
	buffer WIN_BUF1, target_w(0), target_h(0)
	buffer WIN_BUF2, target_w(1), target_h(1)
	buffer WIN_BUF3, target_w(2), target_h(2)

	// 出力ウィンドウ
	bgscr WIN_OUT1, ginfo_dispx, ginfo_dispy
	out_hdc(0) = hdc
	bgscr WIN_OUT2, ginfo_dispx, ginfo_dispy
	out_hdc(1) = hdc

	// ボタン描画
	gsel WIN_SW
	button gosub "系統1-1", *sw1_1
	button gosub "系統1-2", *sw1_2
	button gosub "系統1-3", *sw1_3
	button gosub "系統2-1", *sw2_1
	button gosub "系統2-2", *sw2_2
	button gosub "系統2-3", *sw2_3

	// 動画再生
	repeat
		repeat 2
			// 操作ウィンドウ選択
			gsel win_id(cnt)
			
			redraw 0

			// 背景消去
			color 255, 255, 255
			boxf

			// アスペクト比
			cur_aspect = double(target_w(status(cnt))) / target_h(status(cnt))

			// 画面出力
			if (cur_aspect < ASPECT) {
				StretchBlt out_hdc(cnt), double(ginfo_dispx) / 2 - double(ginfo_dispy) * cur_aspect / 2, 0, double(ginfo_dispy) * cur_aspect, ginfo_dispy, target_hdc(status(cnt)), 0, 0, target_w(status(cnt)), target_h(status(cnt)), 0x00CC0020 | 0x40000000
			} else {
				StretchBlt out_hdc(cnt), 0, double(ginfo_dispy) / 2 - double(ginfo_dispx) / cur_aspect / 2, ginfo_dispx, double(ginfo_dispx) / cur_aspect, target_hdc(status(cnt)), 0, 0, target_w(status(cnt)), target_h(status(cnt)), 0x00CC0020 | 0x40000000
			}

			redraw 1
		loop

		await 33
	loop

*sw1_1
	status(0) = 0
	return

*sw1_2
	status(0) = 1
	return

*sw1_3
	status(0) = 2
	return

*sw2_1
	status(1) = 0
	return

*sw2_2
	status(1) = 1
	return

*sw2_3
	status(1) = 2
	return
