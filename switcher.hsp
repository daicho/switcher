#uselib "user32.dll"
	#cfunc GetDC "GetDC" int
	#func GetClientRect "GetClientRect" int, int
	#func SetWindowLong "SetWindowLongA" int, int, int
	#func GetCursorPos "GetCursorPos" int
	#cfunc WindowFromPoint "WindowFromPoint" int, int

#uselib "gdi32.dll"
	#cfunc CreateDC "CreateDCA" sptr, sptr, sptr, int
	#func DeleteDC "DeleteDC" int
	#func BitBlt "BitBlt" int, int, int, int, int, int, int, int, int
	#func StretchBlt "StretchBlt" int, int,int, int, int, int, int, int, int, int, int

#packopt name "switcher"
#packopt hide 1

#define ASPECT (4.0 / 3.0)

#enum WIN_SW = 1
#enum WIN_BUF1
#enum WIN_BUF2
#enum WIN_BUF3
#enum WIN_OUT1
#enum WIN_OUT2

	dim mousexy, 2
	dim rect, 4
	dimtype cur_aspect, vartype("double")

	dim target_hwnd, 3
	dim target_dc, 3
	dim target_w, 3
	dim target_h, 3

	dim win_id, 2
	dim out_dc, 2
	dim status, 2

	win_id(0) = WIN_OUT1
	win_id(1) = WIN_OUT2

	status(0) = 0
	status(1) = 1

	// 操作ウィンドウ
	screen WIN_SW

	repeat 3
		cls
		mes "入力" + (cnt + 1)
		mes "(Ctrlで確定)"

		repeat
			// Ctrlを押すまで待機
			stick key, 0, 0
			if (key & 64): break
			await 10
		loop

		// マウスカーソル下のウィンドウを登録
		GetCursorPos varptr(mousexy)
		target_hwnd(cnt) = WindowFromPoint(mousexy(0), mousexy(1))
	loop

	// デバイスコンテキスト等を取得
	repeat 3
		target_dc(cnt) = GetDC(target_hwnd(cnt))
		GetClientRect target_hwnd(cnt), varptr(rect)
		target_w(cnt) = rect(2)
		target_h(cnt) = rect(3)
	loop

	// バッファウィンドウ
	buffer WIN_BUF1, target_w(0), target_h(0)
	buffer WIN_BUF2, target_w(1), target_h(1)
	buffer WIN_BUF3, target_w(2), target_h(2)

	// 出力ウィンドウ
	bgscr WIN_OUT1, ginfo_dispx, ginfo_dispy
	out_dc(0) = hdc
	bgscr WIN_OUT2, ginfo_dispx, ginfo_dispy
	out_dc(1) = hdc

	// ボタン描画
	gsel WIN_SW
	button gosub "系統1-1", *sw1_1
	button gosub "系統1-2", *sw1_2
	button gosub "系統1-3", *sw1_3
	button gosub "系統2-1", *sw2_1
	button gosub "系統2-2", *sw2_2
	button gosub "系統2-3", *sw2_3

	// 動画再生
	repeat
		repeat 2
			// 操作ウィンドウ選択
			gsel win_id(cnt)
			
			redraw 0

			// 背景消去
			color 255, 255, 255
			boxf

			// アスペクト比
			cur_aspect = double(target_w(status(cnt))) / target_h(status(cnt))

			// 画面出力
			if (cur_aspect < ASPECT) {
				StretchBlt out_dc(cnt), double(ginfo_dispx) / 2 - double(ginfo_dispy) * cur_aspect / 2, 0, double(ginfo_dispy) * cur_aspect, ginfo_dispy, target_dc(status(cnt)), 0, 0, target_w(status(cnt)), target_h(status(cnt)), 0x00CC0020 | 0x40000000
			} else {
				StretchBlt out_dc(cnt), 0, double(ginfo_dispy) / 2 - double(ginfo_dispx) / cur_aspect / 2, ginfo_dispx, double(ginfo_dispx) / cur_aspect, target_dc(status(cnt)), 0, 0, target_w(status(cnt)), target_h(status(cnt)), 0x00CC0020 | 0x40000000
			}

			redraw 1
		loop

		await 33
	loop

	DeleteDC hdcScreen

*sw1_1
	status(0) = 0
	return

*sw1_2
	status(0) = 1
	return

*sw1_3
	status(0) = 2
	return

*sw2_1
	status(1) = 0
	return

*sw2_2
	status(1) = 1
	return

*sw2_3
	status(1) = 2
	return
